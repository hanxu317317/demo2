'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _draftJs = require('draft-js');

var _immutable = require('immutable');

var _getSafeHtml = require('./get-safe-html');

var _getSafeHtml2 = _interopRequireDefault(_getSafeHtml);

var _sanitizeDraftText = require('./sanitize-draft-text');

var _sanitizeDraftText2 = _interopRequireDefault(_sanitizeDraftText);

var _color = require('../../plugins/color');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var NBSP = '&nbsp;'; /* eslint-disable no-unused-vars */

var SPACE = ' ';
var MAX_DEPTH = 4;
var REGEX_CR = new RegExp('\r', 'g');
var REGEX_LF = new RegExp('\n', 'g');
var REGEX_NBSP = new RegExp(NBSP, 'g');

var inlineTags = {
    b: 'BOLD',
    code: 'CODE',
    del: 'STRIKETHROUGH',
    em: 'ITALIC',
    i: 'ITALIC',
    s: 'STRIKETHROUGH',
    strike: 'STRIKETHROUGH',
    strong: 'BOLD',
    u: 'UNDERLINE'
};

var lastBlock = void 0;

function getColorName(val) {
    for (var key in _color.COLOR_MAP) {
        if (_color.COLOR_MAP.hasOwnProperty(key)) {
            if (_color.COLOR_MAP[key].color === val) {
                return key;
            }
        }
    }
    return null;
}

function getEmptyChunk() {
    return {
        text: '',
        inlines: [],
        entities: [],
        blocks: []
    };
}

function getWhitespaceChunk(inEntity) {
    var entities = inEntity ? [inEntity] : [undefined];
    return {
        text: SPACE,
        inlines: [(0, _immutable.OrderedSet)()],
        entities: entities,
        blocks: []
    };
}

function getSoftNewlineChunk() {
    return {
        text: '\n',
        inlines: [(0, _immutable.OrderedSet)()],
        entities: new Array(1),
        blocks: []
    };
}

function getBlockDividerChunk(blockType, depth) {
    return {
        text: '\r',
        inlines: [(0, _immutable.OrderedSet)()],
        entities: [undefined],
        blocks: [{
            type: blockType,
            depth: Math.max(0, Math.min(MAX_DEPTH, depth))
        }]
    };
}

function getListBlockType(tag, lastList) {
    if (tag === 'li') {
        return lastList === 'ol' ? 'ordered-list-item' : 'unordered-list-item';
    }
    return null;
}

function getBlockMapSupportedTags(blockRenderMap) {
    return blockRenderMap.map(function (config) {
        return config.element;
    }).valueSeq().toSet().toArray().sort();
}

function getMultiMatchedType(tag, lastList, multiMatchExtractor) {
    for (var ii = 0; ii < multiMatchExtractor.length; ii++) {
        var matchType = multiMatchExtractor[ii](tag, lastList);
        if (matchType) {
            return matchType;
        }
    }
    return null;
}

function getBlockTypeForTag(tag, lastList, blockRenderMap) {
    var matchedTypes = blockRenderMap.filter(function (config) {
        return config.element === tag || config.wrapper === tag;
    }).keySeq().toSet().toArray().sort();
    switch (matchedTypes.length) {
        case 0:
            return 'unstyled';
        case 1:
            return matchedTypes[0];
        default:
            return getMultiMatchedType(tag, lastList, [getListBlockType]) || 'unstyled';
    }
}

function processInlineTag(tag, node, currentStyle) {
    var styleToCheck = inlineTags[tag];
    var cStyle = currentStyle;
    if (styleToCheck) {
        cStyle = currentStyle.add(styleToCheck).toOrderedSet();
    } else if (node instanceof HTMLElement) {
        var htmlElement = node;
        cStyle = currentStyle.withMutations(function (style) {
            if (htmlElement.style.fontWeight === 'bold') {
                style.add('BOLD');
            }
            if (htmlElement.style.fontStyle === 'italic') {
                style.add('ItALIC');
            }
            if (htmlElement.style.textDecoration === 'underline') {
                style.add('UNDERLINE');
            }
            // todo add font-size
            var fontSize = htmlElement.style.fontSize;
            if (fontSize) {
                var fontSizeName = 'F_' + fontSize.replace('px', '');
                style.add(fontSizeName);
            }
            var color = htmlElement.style.color;
            var colorName = getColorName(color);
            if (colorName) {
                style.add(colorName);
            }
            // todo add color
        }).toOrderedSet();
    }
    return cStyle;
}

function joinChunks(A, B) {
    return {
        text: A.text + B.text,
        inlines: A.inlines.concat(B.inlines),
        entities: A.entities.concat(B.entities),
        blocks: A.blocks.concat(B.blocks)
    };
}

function containsSemanticBlockMarkup(html, blockTags) {
    return blockTags.some(function (tag) {
        return html.indexOf('<' + tag) !== -1;
    });
}

function hasValidLinkText(link) {
    return link.protocol === 'http:' || link.protocol === 'https:';
}

function genFragment(node, inlineStyle, lastList, inBlock, blockTags, depth, blockRenderMap, inEntity) {
    var nodeName = node.nodeName.toLowerCase();
    var newBlock = false;
    var nextBlockType = 'unstyled';

    // 针对图片 特殊处理一下
    if (node.firstChild && node.firstChild.nodeName.toLowerCase() === 'img') {
        var src = node.firstChild.src;
        var _entityId = _draftJs.Entity.create('IMAGE', 'IMMUTABLE', { src: src });
        return {
            text: '\ri',
            inlines: [(0, _immutable.OrderedSet)(), (0, _immutable.OrderedSet)()],
            entities: [undefined, _entityId],
            blocks: [{
                type: 'atomic',
                depth: depth
            }]
        };
    }
    if (nodeName === '#text') {
        var text = node.textContent;
        if (text.trim() === '' && inBlock !== 'pre') {
            return getWhitespaceChunk(inEntity);
        }
        if (inBlock !== 'pre') {
            text = text.replace(REGEX_LF, SPACE);
        }
        lastBlock = nodeName;
        return {
            text: text,
            inlines: Array(text.length).fill(inlineStyle),
            entities: Array(text.length).fill(inEntity),
            blocks: []
        };
    }
    lastBlock = nodeName;
    var chunk = getEmptyChunk();
    var newChunk = null;

    var iStyle = processInlineTag(nodeName, node, inlineStyle);

    var key = depth;
    var lList = lastList;
    var iBlock = inBlock;
    if (nodeName === 'ul' || nodeName === 'ol') {
        if (lastList) {
            key += 1;
        }
        lList = nodeName;
    }

    if (!inBlock && blockTags.indexOf(nodeName) !== -1) {
        chunk = getBlockDividerChunk(getBlockTypeForTag(nodeName, lList, blockRenderMap), key);
        iBlock = nodeName;
        newBlock = true;
        nextBlockType = lList === 'ul' ? 'unordered-list-item' : 'ordered-list-item';
    }
    var child = node.firstChild;
    if (child !== null) {
        nodeName = child.nodeName.toLowerCase();
    }

    var entityId = null;
    var href = null;

    while (child) {
        if (nodeName === 'a' && child.href && hasValidLinkText(child)) {
            href = child.href;
            entityId = _draftJs.Entity.create('LINK', 'MUTABLE', { url: href });
        } else {
            entityId = undefined;
        }

        newChunk = genFragment(child, iStyle, lList, iBlock, blockTags, key, blockRenderMap, entityId || inEntity);

        chunk = joinChunks(chunk, newChunk);
        var sibling = child.nextSibling;

        if (sibling && blockTags.indexOf(nodeName) >= 0 && iBlock) {
            chunk = joinChunks(chunk, getSoftNewlineChunk());
        }
        if (sibling) {
            nodeName = sibling.nodeName.toLowerCase();
        }
        child = sibling;
    }
    return chunk;
}

function getChunkForHTML(html, blockRenderMap) {
    var aHtml = html.trim().replace(REGEX_CR, '').replace(REGEX_NBSP, SPACE);

    var supportedBlockTags = getBlockMapSupportedTags(blockRenderMap);
    var safeBody = (0, _getSafeHtml2.default)(aHtml);
    if (!safeBody) {
        return null;
    }
    lastBlock = null;

    var workingBlocks = containsSemanticBlockMarkup(aHtml, supportedBlockTags) ? supportedBlockTags : ['div'];
    var chunk = genFragment(safeBody, (0, _immutable.OrderedSet)(), 'ul', null, workingBlocks, -1, blockRenderMap);
    // join with previous block to prevent weirdness on paste
    if (chunk.text.indexOf('\r') === 0) {
        chunk = {
            text: chunk.text.slice(1),
            inlines: chunk.inlines.slice(1),
            entities: chunk.entities.slice(1),
            blocks: chunk.blocks
        };
    }
    // Kill block delimiter at the end
    // if (chunk.text.slice(-1) === '\r') {
    //     chunk.text = chunk.text.slice(0, -1);
    //     chunk.inlines = chunk.inlines.slice(0, -1);
    //     chunk.entities = chunk.entities.slice(0, -1);
    //     chunk.blocks.pop();
    // }
    // If we saw no block tags, put an unstyled one in
    if (chunk.blocks.length === 0) {
        chunk.blocks.push({ type: 'unstyled', depth: 0 });
    }

    // Sometimes we start with text that isn't in a block, which is then
    // followed by blocks. Need to fix up the blocks to add in
    // an unstyled block for this content
    if (chunk.text.split('\r').length === chunk.blocks.length + 1) {
        chunk.blocks.unshift({ type: 'unstyled', depth: 0 });
    }
    return chunk;
}

function importHtml(html) {
    var blockRenderMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _draftJs.DefaultDraftBlockRenderMap;

    var chunk = getChunkForHTML(html, blockRenderMap);
    if (chunk === null) {
        return null;
    }
    var start = 0;
    return chunk.text.split('\r').map(function (textBlock, ii) {
        var text = (0, _sanitizeDraftText2.default)(textBlock);
        var end = start + text.length;
        var inlines = chunk.inlines.slice(start, end);
        var entities = chunk.entities.slice(start, end);
        var characterList = (0, _immutable.List)(inlines.map(function (style, key) {
            var data = {
                style: style,
                entity: null
            };
            if (entities[key]) {
                data.entity = entities[key];
            }
            return _draftJs.CharacterMetadata.create(data);
        }));
        start = end + 1;
        return new _draftJs.ContentBlock({
            key: (0, _draftJs.genKey)(),
            type: chunk.blocks[ii].type,
            depth: chunk.blocks[ii].depth,
            text: text,
            characterList: characterList
        });
    });
}

exports.default = importHtml;
module.exports = exports['default'];